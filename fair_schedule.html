<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fair Work Schedule</title>
  <link rel="icon" href="pb-icon.png" type="image/png">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <style>
    body { font-family: Arial, sans-serif; background-color: #f5faff; color: #333; margin: 0; padding: 0; }
    header { background-color: #0077cc; color: white; padding: 20px 40px; display: flex; justify-content: space-between; align-items: center; }
    header h1 { margin: 0; }
    .nav-buttons a { background-color: white; color: #0077cc; padding: 8px 14px; border-radius: 5px; text-decoration: none; font-weight: bold; margin-left: 8px; }
    .container { max-width: 800px; margin: 40px auto; padding: 20px; background: white; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
    input, button { padding: 8px; margin: 6px 0; width: 100%; border-radius: 5px; border: 1px solid #ccc; box-sizing: border-box; }
    button { background-color: #0077cc; color: white; cursor: pointer; }
    button:hover { background-color: #005fa3; }
    .hidden { display: none; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    th, td { border: 1px solid #ccc; padding: 6px; text-align: left; vertical-align: top; }
    th { background-color: #0077cc; color: white; }
    .error { color: red; font-weight: bold; }
    .weekday { color: black; }
    .weekend { color: #004a99; font-weight: bold; }
    .special { color: darkred; font-weight: bold; }
    .top-buttons { display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 15px; }
    .month-title { font-size: 1.1em; margin-bottom: 8px; color: #333; }
  </style>
</head>
<body>
  <header>
    <h1>Fair Work Schedule</h1>
    <div class="nav-buttons">
      <a href="index.html">Home</a>
      <a href="publications.html">Publications</a>
      <a href="experience.html">Experience</a>
      <a href="talks.html">Talks</a>
      <a href="cv.html" target="_blank">CV</a>
      <a href="contact.html">Contact</a>
    </div>
  </header>

  <!-- Login -->
  <div class="container" id="login-container">
    <h2>Login</h2>
    <label>Username:</label>
    <input type="text" id="username" placeholder="Enter username">
    <label>Password:</label>
    <input type="password" id="password" placeholder="Enter password">
    <button onclick="checkLogin()">Login</button>
    <p id="login-error" class="error"></p>
  </div>

  <!-- Inputs -->
  <div class="container hidden" id="input-container">
    <div class="top-buttons">
      <button onclick="logout()">Log Out</button>
    </div>
    <h2>Enter Parameters</h2>
    <label>Year:</label>
    <input type="number" id="year" min="1900" max="2100" placeholder="e.g., 2025">
    <label>Month (1-12):</label>
    <input type="number" id="month" min="1" max="12" placeholder="e.g., 10">
    <label>Number of Workers (n):</label>
    <input type="number" id="n" min="1" placeholder="e.g., 6">
    <label>Preferred Weekend Off (e.g., [0,2,1,0]):</label>
    <input type="text" id="weekend_off" placeholder="e.g., [0,0,0,0,0,0]">
    <button onclick="generateSchedule()">Generate Schedule</button>
    <p id="input-error" class="error"></p>
  </div>

  <!-- Results -->
  <div class="container hidden" id="result-container">
    <div class="top-buttons">
      <button onclick="refreshInput()">New Input</button>
      <button onclick="logout()">Log Out</button>
    </div>
    <h2>Generated Schedule</h2>
    <div id="month-year" class="month-title"></div>
    <div id="schedule-output"></div>
  </div>

  <script>
    // --- Login persistence ---
    window.onload = function() {
      if (localStorage.getItem('loggedIn') === 'true') {
        document.getElementById('login-container').classList.add('hidden');
        document.getElementById('input-container').classList.remove('hidden');
      }
    };

    function checkLogin() {
      const user = document.getElementById('username').value.trim();
      const pass = document.getElementById('password').value.trim();
      const err = document.getElementById('login-error');
      if (user === 'popcorn' && pass === 'Popcorn22') {
        localStorage.setItem('loggedIn', 'true');
        document.getElementById('login-container').classList.add('hidden');
        document.getElementById('input-container').classList.remove('hidden');
      } else {
        err.textContent = "Invalid username or password!";
      }
    }

    function logout() {
      localStorage.removeItem('loggedIn');
      document.getElementById('input-container').classList.add('hidden');
      document.getElementById('result-container').classList.add('hidden');
      document.getElementById('login-container').classList.remove('hidden');
    }

    function refreshInput() {
      document.getElementById('result-container').classList.add('hidden');
      document.getElementById('input-container').classList.remove('hidden');
      document.getElementById('input-error').textContent = '';
      document.getElementById('n').value = '';
      document.getElementById('year').value = '';
      document.getElementById('month').value = '';
      document.getElementById('weekend_off').value = '';
    }

    // --- Core scheduling heuristic (tries to emulate your MATLAB constraints) ---
    function generateSchedule() {
      const n = parseInt(document.getElementById('n').value);
      const month = parseInt(document.getElementById('month').value);
      const year = parseInt(document.getElementById('year').value);
      const weekend_off_input = document.getElementById('weekend_off').value.trim();
      const err = document.getElementById('input-error');
      err.textContent = "";

      if (isNaN(year) || isNaN(month) || month < 1 || month > 12) {
        err.textContent = "Please enter a valid year and month (1â€“12)."; return;
      }
      if (isNaN(n) || n <= 0) {
        err.textContent = "Number of workers must be a positive integer."; return;
      }

      let weekend_off;
      try {
        weekend_off = JSON.parse(weekend_off_input);
        if (!Array.isArray(weekend_off)) throw "Not array";
      } catch {
        err.textContent = "Weekend off must be a valid array, e.g., [0,2,1,0]."; return;
      }
      if (weekend_off.length !== n) { err.textContent = `The weekend_off vector must have length ${n}.`; return; }

      // calendar info
      const daysInMonth = new Date(year, month, 0).getDate();
      const dow = (d) => new Date(year, month - 1, d).getDay(); // 0=Sun ... 6=Sat
      const daysShort = ['Su','M','T','W','Th','F','Sa'];

      // weights: weekday 0.5, weekend 1.0
      const weights = Array.from({length: daysInMonth}, (_,i) => {
        const dayIdx = dow(i+1);
        return (dayIdx === 0 || dayIdx === 6) ? 1.0 : 0.5;
      });

      // schedule matrix [n x daysInMonth], initialize zeros
      const schedule = Array.from({length: n}, () => Array(daysInMonth).fill(0));

      // helper: check if candidate eligible to be assigned on day d (0-based)
      function eligible(i, d) {
        // weekend_off: if day d is a saturday that matches someone's requested weekend number, that person must be off (both sat & sun)
        // find which weekend index this saturday is
        const dayIdx = dow(d+1);
        if (dayIdx === 6) { // Saturday
          // compute which weekend number this is (1-based)
          // weekend_starts are all Saturdays in the month ordered.
          // Build weekend index mapping once
        }
        // if they already have weekend_off that covers this saturday:
        // We'll check later using precomputed weekendStarts map
        // No 3 weekdays in a row: check previous two days if both weekdays and assigned
        // Note: we only prevent creating a 3-in-row with previous two assigned weekdays
        const prev1 = d-1, prev2 = d-2;
        // check previous two days are within month and are weekdays and had assignment
        if (prev1 >= 0 && prev2 >= 0) {
          const prev1Idx = dow(prev1+1), prev2Idx = dow(prev2+1);
          // consider only weekdays (Mon-Fri) as per your rule (dow 1..5 in MATLAB; here 1..5 translates to JS dayIdx 1..5)
          if (prev1Idx >= 1 && prev1Idx <= 5 && prev2Idx >= 1 && prev2Idx <= 5) {
            if (schedule[i][prev1] === 1 && schedule[i][prev2] === 1) return false;
          }
        }
        // No Sunday+Monday together: if current day is Sunday (0) and next day exists and is Monday, prevent if already assigned next day
        if (dow(d+1) === 0) {
          if (d+1 < daysInMonth && schedule[i][d+1] === 1) return false;
        }
        // Always allow assignment unless weekend_off forbids (we'll check weekend_off below)
        return true;
      }

      // Build weekendStarts array: list of saturday indices (0-based)
      const weekendStarts = [];
      for (let d = 1; d <= daysInMonth; d++) if (dow(d) === 6) weekendStarts.push(d-1);

      // Create a quick set for weekend_off mapping:
      // weekend_off entries give which weekend (1-based) person wants off
      const weekendOffMap = Array(n).fill(-1);
      for (let i = 0; i < n; i++) {
        const w = weekend_off[i];
        if (Number.isInteger(w) && w > 0 && w <= weekendStarts.length) weekendOffMap[i] = weekendStarts[w-1]; // saturday index
      }

      // Current points per person
      const points = Array(n).fill(0);

      // Function to add points when assign (d is 0-based)
      function addPoints(i, d) { points[i] += weights[d]; }

      // Helper chooseCandidates: pick k eligible workers for day d using fairness (lowest points)
      function chooseCandidates(d, k) {
        // produce array of {i, points} for eligible workers, excluding those forbidden by weekend_off for this day's weekend pair
        const arr = [];
        const dayIdx = dow(d+1);
        const isWeekend = (dayIdx === 6 || dayIdx === 0);
        for (let i = 0; i < n; i++) {
          // skip if weekend_off forbids this saturday/sunday
          if (isWeekend) {
            // If this day is Sat or Sun, find saturday index of that weekend
            let saturdayIndex = (dayIdx === 6) ? d : d-1; // if this day is Sunday, saturday is d-1
            if (saturdayIndex >= 0) {
              if (weekendOffMap[i] === saturdayIndex) continue;
            }
          }
          // skip if person already has assignment on this day (shouldn't happen)
          if (schedule[i][d] > 0) continue;
          // check 3-weekday constraint and sun+mon
          if (!eligible(i,d)) continue;
          arr.push({i, p: points[i]});
        }
        // sort ascending by points, break ties by index
        arr.sort((a,b) => a.p - b.p || a.i - b.i);
        // return top k indices if available
        return arr.slice(0, k).map(x => x.i);
      }

      // MAIN ASSIGNMENT LOGIC:
      // We iterate days in order. For weekdays -> assign 1 worker (choose lowest points eligible).
      // For a Friday, we prefer to assign someone who can also take Sat+Sun (to satisfy Friday->Sat->Sun linkage),
      // but we must still ensure weekend counts of 2 each.
      for (let d = 0; d < daysInMonth; d++) {
        const dayIdx = dow(d+1);
        const isSaturday = (dayIdx === 6);
        const isSunday = (dayIdx === 0);
        const isWeekend = isSaturday || isSunday;
        const required = isWeekend ? 2 : 1;

        // For Saturdays, enforce Sat==Sun: we will assign pairs on Saturday and mirror to Sunday later.
        if (isSaturday) {
          // Choose 2 candidates for the weekend pair (taking into account weekend_off and current points)
          const pair = chooseCandidates(d, 2);

          // If we couldn't find enough candidates (rare), allow fallback: consider everyone but weekend_off
          if (pair.length < 2) {
            // try include people who were ineligible due to eligible() (relax)
            const fallback = [];
            for (let i=0;i<n;i++) {
              // skip weekend_off forbids
              if (weekendOffMap[i] === d) continue;
              if (schedule[i][d] === 0) fallback.push({i,p:points[i]});
            }
            fallback.sort((a,b)=>a.p-b.p||a.i-b.i);
            for (let f of fallback) if (!pair.includes(f.i)) pair.push(f.i);
            pair.splice(2);
          }

          // assign both Sat and Sun the same pair (enforce Sat==Sun)
          for (const i of pair) {
            schedule[i][d] = 2; // mark as weekend assignment (2)
            addPoints(i,d);
            // assign Sunday (if exists)
            if (d+1 < daysInMonth && dow(d+2) === 0) {
              schedule[i][d+1] = 2;
              addPoints(i,d+1);
            }
          }
          // For the case Sunday needs 2 workers and pair already supplies 2, we're done.
          // If Sunday exists and needs 2 but pair was only 2 (done above), ok.
          // Note: Saturday assignment consumes weekend slots for Sunday as well via pair.
          // We still need to ensure total of 2 for Sunday if Saturday was not used to assign both; handled earlier since we mirrored.

          // Skip assigning Sunday when loop reaches it because we've already assigned both.
        }
        else if (isSunday) {
          // If Sunday was already assigned by previous Saturday mirroring, skip.
          // Otherwise assign normally (rare if month starts on Sunday)
          if (schedule.some(row => row[d] > 0)) continue;
          const candidates = chooseCandidates(d, 2);
          for (let idx = 0; idx < Math.min(2, candidates.length); idx++) {
            const i = candidates[idx];
            schedule[i][d] = 2;
            addPoints(i,d);
          }
        }
        else {
          // weekday
          // select 1 candidate
          const candidates = chooseCandidates(d, 1);
          if (candidates.length === 0) {
            // fallback: relax the eligible() check by considering anyone not weekend-off for this day
            for (let i=0;i<n;i++) {
              if (schedule[i][d] === 0) candidates.push(i);
              if (candidates.length>=1) break;
            }
          }
          if (candidates.length > 0) {
            const chosen = candidates[0];
            schedule[chosen][d] = 1;
            addPoints(chosen,d);

            // If day is Friday (4 -> where Sunday=0 => Fri=5? careful): JS day: 5 is Friday? JS: Sun=0 Mon=1 Tue=2 Wed=3 Thu=4 Fri=5 Sat=6
            // So Friday has dayIdx === 5. If chosen is assigned Fri and Fri not in any d_temp exclusions, enforce they also be assigned Sat and Sun (if within month and not weekend_off).
            if (dayIdx === 5) { // Friday
              // find saturday index
              const satIndex = d + 1; // next day
              const sunIndex = d + 2;
              if (satIndex < daysInMonth && dow(satIndex+1) === 6) {
                // Only enforce if the chosen worker is eligible for that weekend (not requested off)
                if (weekendOffMap[chosen] !== satIndex) {
                  // assign them to sat/sun if slots available (we may need to move others later)
                  if (schedule[chosen][satIndex] === 0) { schedule[chosen][satIndex] = 1; addPoints(chosen,satIndex); }
                  if (sunIndex < daysInMonth && schedule[chosen][sunIndex] === 0) { schedule[chosen][sunIndex] = 1; addPoints(chosen,sunIndex); }
                }
              }
            }
          }
        }
      } // end day loop

      // Final pass: ensure weekend days have exactly 2 workers and Sat==Sun
      // For each weekend start (saturday index) we ensure Sat and Sun assigned persons match and total 2
      for (const satIdx of weekendStarts) {
        const sunIdx = satIdx + 1;
        // build current assigned sets
        const satAssigned = [];
        const sunAssigned = [];
        for (let i=0;i<n;i++) {
          if (schedule[i][satIdx] > 0) satAssigned.push(i);
          if (sunIdx < daysInMonth && schedule[i][sunIdx] > 0) sunAssigned.push(i);
        }
        // If satAssigned length < 2, pick additional candidates (respect weekend_off)
        if (satAssigned.length < 2) {
          const need = 2 - satAssigned.length;
          const candidates = [];
          for (let i=0;i<n;i++) {
            if (weekendOffMap[i] === satIdx) continue;
            if (!satAssigned.includes(i)) candidates.push({i,p:points[i]});
          }
          candidates.sort((a,b)=>a.p-b.p||a.i-b.i);
          for (let k=0;k<need && k<candidates.length;k++) {
            const idx = candidates[k].i;
            if (schedule[idx][satIdx] === 0) { schedule[idx][satIdx] = 2; addPoints(idx,satIdx); }
            if (sunIdx < daysInMonth && schedule[idx][sunIdx] === 0) { schedule[idx][sunIdx] = 2; addPoints(idx,sunIdx); }
          }
        }
        // If sunAssigned length < 2 mirror satAssigned into sunAssigned
        if (sunIdx < daysInMonth) {
          const satAssignedNow = [];
          for (let i=0;i<n;i++) if (schedule[i][satIdx] > 0) satAssignedNow.push(i);
          // ensure sun has same people (Sat==Sun)
          for (const idx of satAssignedNow) {
            if (schedule[idx][sunIdx] === 0 && weekendOffMap[idx] !== satIdx) { schedule[idx][sunIdx] = 2; addPoints(idx,sunIdx); }
          }
          // if after mirroring we still have less than 2, fill up with lowest points
          const sunAssignedNow = [];
          for (let i=0;i<n;i++) if (schedule[i][sunIdx] > 0) sunAssignedNow.push(i);
          if (sunAssignedNow.length < 2) {
            const need = 2 - sunAssignedNow.length;
            const candidates = [];
            for (let i=0;i<n;i++) {
              if (weekendOffMap[i] === satIdx) continue;
              if (!sunAssignedNow.includes(i)) candidates.push({i,p:points[i]});
            }
            candidates.sort((a,b)=>a.p-b.p||a.i-b.i);
            for (let k=0;k<need && k<candidates.length;k++) {
              const idx = candidates[k].i;
              if (schedule[idx][sunIdx] === 0) { schedule[idx][sunIdx] = 2; addPoints(idx,sunIdx); }
            }
          }
        }
      }

      // --- Prepare output ---
      document.getElementById('input-container').classList.add('hidden');
      document.getElementById('result-container').classList.remove('hidden');

      // Show month and year at top
      const monthName = new Date(year, month-1, 1).toLocaleString(undefined, { month: 'long' });
      document.getElementById('month-year').textContent = `Schedule for ${monthName} ${year}`;

      const outDiv = document.getElementById('schedule-output');
      outDiv.innerHTML = createCompactTable(schedule, daysShort, year, month, weights);
      // scroll into view
      document.getElementById('result-container').scrollIntoView({behavior: 'smooth'});
    }

    // createCompactTable: prints only assigned dates per person (colored)
    function createCompactTable(schedule, days, year, month, weights) {
      let tableHTML = `<table><tr><th>Worker</th><th>Assigned Dates (date(day))</th></tr>`;
      for (let i = 0; i < schedule.length; i++) {
        let assignments = [];
        for (let d = 0; d < schedule[i].length; d++) {
          const val = schedule[i][d];
          if (val > 0) {
            const dayIdx = new Date(year, month - 1, d + 1).getDay();
            const dayName = days[dayIdx];
            const colorClass = (val === 2)
              ? "special"
              : (dayName === "Sa" || dayName === "Su") ? "weekend" : "weekday";
            assignments.push(`<span class="${colorClass}">${d + 1}(${dayName})</span>`);
          }
        }
        tableHTML += `<tr><td><b>Worker ${i + 1}</b></td><td>${assignments.join(', ') || '<i>none</i>'}</td></tr>`;
      }
      tableHTML += `</table>`;
      return tableHTML;
    }

  </script>
</body>
</html>
